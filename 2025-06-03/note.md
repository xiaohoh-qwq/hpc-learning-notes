# lecture 3 课程学习笔记

## 1. 并行计算性能指标

### 1.1 加速比 (Speedup, $S$)

**加速比**是衡量并行算法相对于最快串行算法性能提升的指标。

$$S = \frac{T_s}{T_p}$$


其中：

* $T_s$：最快串行算法的执行时间。

* $T_p$：使用 $p$ 个处理器时并行算法的执行时间。

### 1.2 效率 (Efficiency, $E$)

**效率**表示处理器被有效利用的比例。

$$E = \frac{S}{p} = \frac{T_s}{p \cdot T_p}$$


理想情况下 $E=1$ (或 100%)，但实际中 $0 \le E \le 1$。

### 1.3 开销 (Overheads, $T_o$)

**开销**是并行程序中存在的、阻碍理想加速比实现的额外成本。

$$T_o = p \cdot T_p - T_s$$

效率也可以用开销表示：

$$E = \frac{T_s}{T_s + T_o} = \frac{1}{1 + \frac{T_o}{T_s}}$$


主要开销来源：

* 进程/线程间的**通信**或**同步**。

* 各处理器/线程间的**负载不均衡**。

* 为管理计算和增加并行性而引入的**额外工作**。

## 2. 加速比的限制因素 

### 2.1 阿姆达尔定律 (Amdahl's Law)

**阿姆达尔定律**用于预测使用多个处理器进行并行计算时的理论最大加速比。它指出程序中的**串行部分** ($\beta$) 会限制整体加速比。
假设程序总操作量中：

* $\beta$ 部分是纯串行的。

* $1-\beta$ 部分是完全可并行的。

使用 $p$ 个处理器时的并行时间 $T_p$ 为：

$$T_p = \beta \cdot T_s + \frac{(1-\beta) \cdot T_s}{p}$$

因此，加速比 $S$ 为：

$$S = \frac{T_s}{T_p} = \frac{1}{\beta + \frac{1-\beta}{p}}$$


当处理器数量 $p \to \infty$ 时，最大加速比 $S_{max} \to \frac{1}{\beta}$。
例如，若程序中5%是串行的 ($\beta = 0.05$)，则无论使用多少处理器，最大加速比不会超过 20。

### 2.2 开销的影响

实际加速比通常小于理想加速比，且随着处理器数量增加，差距可能更大，主要原因就是**开销**。因此，设计并行算法时必须尽量**最小化所有不必要的开销**。

## 3. 并行算法设计 

### 3.1 通用设计流程

并行算法设计通常需要创造性思维，主要包括两个阶段：

1. **机器无关阶段 (Machine Independent Stage):**

   * 根据问题特性识别并行执行的机会。

   * 主要活动：**划分 (Partitioning)**、**通信/同步 (Communication/Synchronization)**。

2. **机器相关阶段 (Machine Dependent Stage):**

   * 根据特定机器的特性重组任务并分配。

   * 主要活动：**分配 (Assignment)**、**负载均衡 (Load Balancing)**。

### 3.2 机器无关阶段详解

#### 3.2.1 划分 (Partitioning)

目标是定义大量的小任务以暴露并行性。

* **任务划分 (Task Partitioning):** 先划分计算，再关联数据。

* **数据划分 (Data Partitioning):** 先划分数据，再关联计算。
  选择哪种方式取决于具体问题。

#### 3.2.2 通信/同步 (Communication/Synchronization)

划分产生的任务通常不能独立执行，需要数据传输和执行协调。高效组织通信至关重要。

#### 3.2.3 任务依赖图 (Task-Dependency Graph)

* **定义:** 节点代表任务，有向边表示任务间的依赖关系。

* **目的:** 展示算法的并行结构、规律性、依赖特征、工作量预测等。

#### 3.2.4 数学结合律的应用 (Math Associative Law)

利用数学定律（如加法的结合律）可以增加算法的并行度。

* **例子：N个数求和**

  * 串行方法：`s = s + a[i]`，完全串行。

  * 利用结合律：$\sum_{i=0}^{2n-1} a_i = \sum_{i=0}^{n-1} a_i + \sum_{i=n}^{2n-1} a_i$。可以递归地进行成对相加，形成二叉树结构。

  * 这是一种**分治 (Divide and Conquer)** 技术，广泛用于归约操作 (reduction operations)。

### 3.3 机器相关阶段详解

#### 3.3.1 任务分配与负载均衡 (Assignment and Load Balancing)

将任务分配给多个进程/线程，目标是最小化开销并使各处理器负载均衡。

## 4. 示例与技术应用 

### 4.1 矩阵向量乘法 ($y = A \cdot b$)

* **任务划分:** 计算 $y$ 的每个元素 $y_i$ 作为一个任务（涉及 $A$ 的一行和向量 $b$）。任务大小统一，任务间无依赖，属于**易并行 (Embarrassingly Parallel)**。

* **数据划分:** 划分矩阵 $A$ 和向量 $b$，每个 $a_{ij} \cdot b_j$ 作为小任务。这些小任务的结果是中间结果，需要进一步的通信/同步（如内积求和）。适合**细粒度并行 (Fine-grained Parallelism)**。

### 4.2 N个数求和

如3.2.4所述，通过利用加法的结合律，可以将原本串行的求和过程并行化，显著提高并行度。
