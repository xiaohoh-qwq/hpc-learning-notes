# lecture2学习笔记

## 1. Memory Hierarchy（内存层级结构）

### 1.1 性能瓶颈
- 多数未优化的并行程序运行速度不足机器峰值性能的 10%
- 性能损耗主要来源于内存系统而非计算单元
- Caches、Registers 和 ILP（指令级并行）由硬件和编译器管理
  - 有时优化良好，但有时优化失效
- 程序员需手动编写更“明显”的程序结构，帮助编译器和硬件优化

### 1.2 层级结构概览
- 层级从上至下：
  - Register
  - L1 Cache（本地）
  - L2 Cache（本地）
  - L3 Cache（共享）
  - Main Memory（主存）
  - Secondary Memory（磁盘）
- 越往上：**更低延迟、更高带宽、更小容量**
- 越往下：**更高延迟、更低带宽、更大容量**

### 1.3 局部性原则
- **Temporal locality**：重用最近访问过的数据
- **Spatial locality**：访问接近上次访问位置的数据

### 1.4 提升内存系统性能的策略
- 重用已加载的值 → Temporal locality
- 一次性加载连续内存块 → Spatial locality

---

## 2. Computational Intensity（计算强度）

### 2.1 基本定义
- 简化模型：快存与慢存两层结构
- 参数定义：
  - m: 快慢内存间传输的数据元素数
  - tm: 每次慢内存访问的时间
  - f: 算术操作数目
  - tf: 每次计算的时间（小于 tm）

### 2.2 理想与实际时间
- 理想运行时间（全部数据在快存中）：T_min = f × tf
- 实际时间（考虑访存）：T = f × tf + m × tm = f × tf × (1 + (m / f) × (tm / tf))
- 定义计算强度：q = f / m
- 定义机器平衡比：B = tm / tf
- 满足：q > B ⇒ 可达到至少一半峰值性能

### 2.3 提升计算强度的方法
- 提高 q（单位访存对应更多运算）
- 减少 cache miss
- 使用 **连续内存访问**
- **Blocking**（分块）
- 更高效使用寄存器：
- **Loop unrolling**（循环展开）

---

## 3. Matrix Multiplication（矩阵乘法）

### 3.1 传统ijk算法

for (i = 0; i < n; i++)  
 for (j = 0; j < n; j++)  
  for (k = 0; k < n; k++)  
   C[i][j] += A[i][k] * B[k][j];

### 3.2 内存访问分析
- 读取每行 A：n² 次
- 读取每列 B：n³ 次（每列重复读）
- 每元素读取与写入各一次：2n² 次
- 总访存次数：m ≈ n³ + 3n²
- 总浮点运算次数：f = 2n³（一次乘加算两次）
- 计算强度估算：q = f / m ≈ 2n³ / (n³ + 3n²) ≈ 2  （当 n 足够大）

### 3.3 空间复杂度与理论上限
- 总数据量：3n²（A, B, C）
- 最佳理想强度：q_ideal ≈ 2n³ / (4n²) = 0.5n  → 仍有优化空间

---

for (i = 0; i < n; i++)  
 for (k = 0; k < n; k++) {  
  float aik = A[i][k];  
  for (j = 0; j < n; j++)  
   C[i][j] += aik * B[k][j];  
 }

- 内存访问方式：

  A[i][k]：按行访问（良好）  
  B[k][j]：访问整行（良好）  
  C[i][j]：逐行访问（良好）

- 减少了列式访问带来的 cache miss

---

## 5. 优化策略概览

### 5.1 Blocking（分块）
- 将大矩阵分成可装入 cache 的小块
- 在块中完成全部运算，减少全局访问次数，显著提升局部性（Temporal & Spatial）

### 5.2 Loop Unrolling（循环展开）
- 将循环体手动展开，减少分支与索引计算
- 更好利用 CPU 寄存器与指令流水线
- 通常配合编译器优化使用效果更佳
